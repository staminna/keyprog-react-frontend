#!/usr/bin/env node

/**
 * Directus Schema Type Generator
 * Generates TypeScript types from Directus schema for frontend type safety
 */

import { readFileSync, writeFileSync } from 'fs';

interface DirectusField {
  collection: string;
  field: string;
  type: string;
  meta?: {
    interface?: string;
    options?: any;
    special?: string[];
  };
  schema?: {
    data_type: string;
    is_nullable: boolean;
    max_length?: number;
    numeric_precision?: number;
    numeric_scale?: number;
  };
}

interface DirectusCollection {
  collection: string;
  meta: {
    singleton?: boolean;
    icon?: string;
  };
  fields?: DirectusField[];
}

interface DirectusSchema {
  collections: DirectusCollection[];
  fields: DirectusField[];
}

// Type mapping from Directus types to TypeScript
const typeMapping: Record<string, string> = {
  'string': 'string',
  'text': 'string',
  'boolean': 'boolean',
  'integer': 'number',
  'bigInteger': 'number',
  'float': 'number',
  'decimal': 'number',
  'timestamp': 'string',
  'datetime': 'string',
  'date': 'string',
  'time': 'string',
  'json': 'any',
  'uuid': 'string',
  'email': 'string',
  'url': 'string',
  'slug': 'string',
};

// Map Directus field type to TypeScript
function mapDirectusTypeToTypeScript(field: DirectusField): string {
  // Handle special field types
  if (field.meta?.special?.includes('file')) {
    return 'string | null'; // UUID of file
  }
  
  if (field.meta?.interface === 'list') {
    return 'any[]'; // JSON array
  }

  // Handle JSON fields
  if (field.type === 'json' || field.schema?.data_type === 'json') {
    return 'any';
  }

  // Handle numeric types
  if (['integer', 'bigInteger', 'float', 'decimal'].includes(field.type)) {
    return 'number | null';
  }

  // Handle boolean
  if (field.type === 'boolean') {
    return 'boolean | null';
  }

  // Handle string-based types
  const baseType = typeMapping[field.type] || 'string';
  return field.schema?.is_nullable ? `${baseType} | null` : baseType;
}

// Generate interface for a collection
function generateCollectionInterface(collection: DirectusCollection, fields: DirectusField[]): string {
  const collectionFields = fields.filter(f => f.collection === collection.collection);
  
  let interfaceBody = '';
  
  // Add standard Directus fields
  interfaceBody += `  id?: string;\n`;
  
  for (const field of collectionFields) {
    if (field.field === 'id') continue; // Skip duplicate ID field
    
    const tsType = mapDirectusTypeToTypeScript(field);
    const optional = field.schema?.is_nullable ? '?' : '';
    const fieldName = field.field.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
    
    interfaceBody += `  ${fieldName}${optional}: ${tsType};\n`;
  }

  // Add standard timestamp fields if they exist
  const hasDateFields = collectionFields.some(f => f.field.includes('date') || f.field.includes('time'));
  if (hasDateFields) {
    interfaceBody += `  date_created?: string;\n`;
    interfaceBody += `  date_updated?: string;\n`;
  }

  const interfaceName = collection.collection
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');

  return `export interface Directus${interfaceName} {\n${interfaceBody}}\n\n`;
}

// Generate main schema type
function generateSchemaType(collections: DirectusCollection[], fields: DirectusField[]): string {
  let schemaType = 'export interface DirectusSchema {\n';
  
  for (const collection of collections) {
    if (collection.collection.startsWith('directus_')) continue; // Skip system collections
    
    const interfaceName = collection.collection
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
    
    const isArray = !collection.meta?.singleton;
    const type = `Directus${interfaceName}`;
    
    schemaType += `  ${collection.collection}: ${isArray ? `${type}[]` : type};\n`;
  }
  
  schemaType += '}\n\n';
  return schemaType;
}

async function generateTypesFromSchema(): Promise<void> {
  try {
    console.log('üîÑ Generating TypeScript types from Directus schema...');
    
    // Read the schema file

    const schemaPath = '../../keyprog-directus/extensions/current-schema.json';
    const schemaContent = readFileSync(schemaPath, 'utf-8');
    const schema: DirectusSchema = JSON.parse(schemaContent);
    
    let typesContent = `/**
 * Auto-generated TypeScript types from Directus Schema
 * Generated on: ${new Date().toISOString()}
 * DO NOT EDIT MANUALLY - This file is automatically generated
 */

`;
    
    // Generate interfaces for each collection
    for (const collection of schema.collections) {
      if (collection.collection.startsWith('directus_')) continue; // Skip system collections
      
      typesContent += generateCollectionInterface(collection, schema.fields);
    }
    
    // Generate main schema type
    typesContent += generateSchemaType(schema.collections, schema.fields);
    
    // Add common utility types
    typesContent += `// Utility types for Directus operations
export type DirectusItem<T extends keyof DirectusSchema> = DirectusSchema[T] extends (infer U)[] ? U : DirectusSchema[T];
export type DirectusCollectionItems<T extends keyof DirectusSchema> = DirectusSchema[T];
export type DirectusSingleton<T extends keyof DirectusSchema> = DirectusSchema[T];

// Status types commonly used
export type DirectusStatus = 'draft' | 'published' | 'archived';

// Common field types
export interface DirectusFile {
  id: string;
  title: string;
  filename_disk: string;
  filename_download: string;
  type: string;
  filesize: number;
  width: number;
  height: number;
}
`;
    
    // Write to types file
    const outputPath = '../src/types/directus-schema.ts';
    writeFileSync(outputPath, typesContent);
    
    console.log(`‚úÖ Generated TypeScript types: ${outputPath}`);
    console.log(`üìä Generated types for ${schema.collections.filter(c => !c.collection.startsWith('directus_')).length} collections`);
    
  } catch (error) {
    console.error('‚ùå Error generating types:', error);
    process.exit(1);
  }
}

// CLI execution
if (import.meta.url === `file://${process.argv[1]}`) {
  generateTypesFromSchema();
}

export { generateTypesFromSchema };